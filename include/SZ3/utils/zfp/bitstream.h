#ifndef BITSTREAM_H
#define BITSTREAM_H

#include <cassert>
#include <climits>
#include <cstdlib>
#include "types.h"

typedef unsigned char uchar;
typedef unsigned int uint;

/*
This bitstream implementation has been optimized for use with the
integer coder, and has been designed with the following considerations
in mind:

  1. Reads are more common than writes.  Most writes are updates
     that require a corresponding read.  Hence, read performance
     is favored over write performance.

  2. Most reads/writes involve single bits.  These are optimized
     in favor of multi-bit reads/writes.

  3. Multi-bit writes generally involve few bits.

  4. Registers are precious, and hence the state is reduced to
     only a pointer and a byte buffer.

  5. The stream can both be read from and written to with no special
     initialization for either access mode.  Similarly, there is no
     special seek call for read or write access.
*/

// bit stream I/O
class MemoryBitStream {
public:
  MemoryBitStream() : ptr(0), begin(0), end(0) {}
  MemoryBitStream(void* p, size_t n) { open(p, n); }

  // open stream for reading or writing
  void open(void* p, size_t n)
  {
    begin = ptr = (uchar*)p;
    end = ptr + n;
    buffer = 1u;
  }

  // stream byte length
  size_t size() const { return ptr - begin; }

  // rewind stream to beginning
  void rewind() { seek(0); }

  // seek to a whole-byte offset
  void seek(size_t offset)
  {
    ptr = begin + offset;
    buffer = 1u;
  }

  // read single bit
  inline bool read();

  // read n-bit value
  inline uint read(uint n);

  // write single bit
  inline bool write(bool bit);

  // write n-bit value
  inline bool write(uint value, uint n);

  // flush out any remaining buffered bits
  inline bool flush();

  // align input stream to byte boundary
  inline bool align();

protected:
  // bit reversal table used by writer
  static uchar reverse(uchar x)
  {
    static const uchar lut[] align_(256) = {
      0x00,0x80,0x40,0xc0,0x20,0xa0,0x60,0xe0,0x10,0x90,0x50,0xd0,0x30,0xb0,0x70,0xf0,
      0x08,0x88,0x48,0xc8,0x28,0xa8,0x68,0xe8,0x18,0x98,0x58,0xd8,0x38,0xb8,0x78,0xf8,
      0x04,0x84,0x44,0xc4,0x24,0xa4,0x64,0xe4,0x14,0x94,0x54,0xd4,0x34,0xb4,0x74,0xf4,
      0x0c,0x8c,0x4c,0xcc,0x2c,0xac,0x6c,0xec,0x1c,0x9c,0x5c,0xdc,0x3c,0xbc,0x7c,0xfc,
      0x02,0x82,0x42,0xc2,0x22,0xa2,0x62,0xe2,0x12,0x92,0x52,0xd2,0x32,0xb2,0x72,0xf2,
      0x0a,0x8a,0x4a,0xca,0x2a,0xaa,0x6a,0xea,0x1a,0x9a,0x5a,0xda,0x3a,0xba,0x7a,0xfa,
      0x06,0x86,0x46,0xc6,0x26,0xa6,0x66,0xe6,0x16,0x96,0x56,0xd6,0x36,0xb6,0x76,0xf6,
      0x0e,0x8e,0x4e,0xce,0x2e,0xae,0x6e,0xee,0x1e,0x9e,0x5e,0xde,0x3e,0xbe,0x7e,0xfe,
      0x01,0x81,0x41,0xc1,0x21,0xa1,0x61,0xe1,0x11,0x91,0x51,0xd1,0x31,0xb1,0x71,0xf1,
      0x09,0x89,0x49,0xc9,0x29,0xa9,0x69,0xe9,0x19,0x99,0x59,0xd9,0x39,0xb9,0x79,0xf9,
      0x05,0x85,0x45,0xc5,0x25,0xa5,0x65,0xe5,0x15,0x95,0x55,0xd5,0x35,0xb5,0x75,0xf5,
      0x0d,0x8d,0x4d,0xcd,0x2d,0xad,0x6d,0xed,0x1d,0x9d,0x5d,0xdd,0x3d,0xbd,0x7d,0xfd,
      0x03,0x83,0x43,0xc3,0x23,0xa3,0x63,0xe3,0x13,0x93,0x53,0xd3,0x33,0xb3,0x73,0xf3,
      0x0b,0x8b,0x4b,0xcb,0x2b,0xab,0x6b,0xeb,0x1b,0x9b,0x5b,0xdb,0x3b,0xbb,0x7b,0xfb,
      0x07,0x87,0x47,0xc7,0x27,0xa7,0x67,0xe7,0x17,0x97,0x57,0xd7,0x37,0xb7,0x77,0xf7,
      0x0f,0x8f,0x4f,0xcf,0x2f,0xaf,0x6f,0xef,0x1f,0x9f,0x5f,0xdf,0x3f,0xbf,0x7f,0xff,
    };
    return lut[x];
  }

  uint buffer;  // byte-wide buffer for incoming/outgoing bits
  uchar* ptr;   // pointer to next byte to be read/written
  uchar* begin; // beginning of stream
  uchar* end;   // end of stream
};

// read single bit from stream
bool
MemoryBitStream::read()
{
  if (!(buffer >> 1u))
    buffer = 0x100u + *ptr++;
  bool bit = buffer & 1u;
  buffer >>= 1u;
  return bit;
}

// read n-bit value from stream
uint
MemoryBitStream::read(uint n)
{
  // read bits in MSB to LSB order
  uint value = 0;
  while (n--)
    value = (value << 1u) + read();
  return value;
}

// write single bit to stream
bool
MemoryBitStream::write(bool bit)
{
  buffer = (buffer << 1u) + bit;
  if (buffer >= 0x100u) {
    *ptr++ = reverse(buffer - 0x100u);
    buffer = 1u;
  }
  return true;
}

// write n-bit value to stream
bool
MemoryBitStream::write(uint value, uint n)
{
  // write bits in MSB to LSB order
  while (n--)
    write((value >> n) & 1u);
  return true;
}

// flush buffered bits and align with next byte boundary
bool
MemoryBitStream::flush()
{
  while (buffer != 1u)
    write(false);
  return true;
}

// read bits up to next byte boundary
bool
MemoryBitStream::align()
{
  buffer = 1u;
  return true;
}

#endif
